本文基于 [Session 10168](https://developer.apple.com/videos/play/wwdc2021/10168/) 梳理


官方 [示例代码](https://developer.apple.com/documentation/mailkit/build_mail_app_extensions)


在 21 年的 WWDC 推出了一个邮件扩展的新框架 MailKit。这套框架的主要作用就是提升邮件使用的体验，框架实现的功能主要通过以下四个方面体现

1. Compose 
2. Action
3. Content blocking
4. Message security
# Compose
所有的功能都在 MEComposeSessionHandler 这个协议里。在开发Compose 扩展的时候，需要在 Info.plist 文件中，MEComposeSession 字典里，指定一个图标和工具的描述性文字。撰写邮件窗口内就会显示这个按钮。
![48F69B31-3F29-4F45-BCE9-0E7A2939F880.jpeg](https://cdn.nlark.com/yuque/0/2021/jpeg/1274781/1624101039216-8c654915-a332-4261-9843-7039b013b2f0.jpeg#clientId=u6cf89c0b-11e5-4&from=ui&height=435&id=u7c5bb441&margin=%5Bobject%20Object%5D&name=48F69B31-3F29-4F45-BCE9-0E7A2939F880.jpeg&originHeight=869&originWidth=858&originalType=binary&ratio=2&size=79806&status=done&style=none&taskId=ue758a358-9e3a-445d-8f51-8170b28e894&width=429)​
下面是方法的一些简单描述
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624089664154-04f97606-cc48-45fa-abdc-99eac68c2792.png#clientId=uede728f9-e3ce-4&from=paste&height=359&id=ufb2a0fd0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=718&originWidth=1414&originalType=binary&ratio=2&size=375502&status=done&style=none&taskId=u15efb591-1e1e-4cc6-a462-93b52c3f5dc&width=707)
在协议里的方法，都包含了 MEComposeSession 这个参数类型。
邮件为每个邮件撰写窗口创建一个唯一的 MEComposeSession 实例。它有一个 MEMessage 属性，用于公开正在编辑的消息的各种详细信息。这些信息就可以在调用扩展程序的时候做对应的处理。
然后不同的处理规则就可以通过和视图控制器进行选择和调整。
自定义消息表头这里先不提，在后续中再提到。
### 验证收件人邮箱地址
每次在输入地址之后，扩展方法就会验证邮箱地址的有效性，然后给出对应的状态。
![BFE7E706-F2CD-421B-8899-97D27B467A00.jpeg](https://cdn.nlark.com/yuque/0/2021/jpeg/1274781/1624101246172-b602fcd3-9390-469b-9d77-ae45b006f0ef.jpeg#clientId=u57db3155-f7d2-4&from=ui&id=uc0f01923&margin=%5Bobject%20Object%5D&name=BFE7E706-F2CD-421B-8899-97D27B467A00.jpeg&originHeight=99&originWidth=781&originalType=binary&ratio=2&size=20706&status=done&style=none&taskId=u20824c36-e241-4290-aa1b-7c8ad377e85)
### 视图控制器
在视图控制器里我们可以进行交互。这里的目的就是为了选择和调整我们需要的邮件信息处理规则。需要特别指出，这里的控制器，需要继承自 MEExtensionViewController ，其实在方法里也有体现。
### 邮件信息验证
在发送邮件之前，还可以对整个邮件内容做一次验证。包括邮件里包括的所有地址，还有邮件的内容。要注意的是邮件的正文内容是以 Data 的形式返回。
​

# Action 
action 主要是用来处理新接收的邮件。这里需要主要：只是处理新接受的邮件，原有的邮件是不会收到影响的。处理的方式包括

1. 标记邮件列表中显示的背景色
2. 移动邮件到对应的邮件文件夹
3. 修改邮件的读取状态和标记

![image.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624094248589-ddedee7f-aadb-44b1-b9cb-98a9c83d0594.png#clientId=uede728f9-e3ce-4&from=paste&height=200&id=ua4c09b8a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=400&originWidth=1302&originalType=binary&ratio=2&size=178217&status=done&style=none&taskId=u6a70b913-990c-46dd-93a6-26cd3f8f5f9&width=651)
在session里，实现的是将邮件列表的背景色修改为红色。
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624093445848-8c433ae6-2e1e-4b33-9c5e-4fe6c3c9ebe0.png#clientId=uede728f9-e3ce-4&from=drop&id=haS0w&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2048&originWidth=2732&originalType=binary&ratio=2&size=1805892&status=done&style=none&taskId=u47c60d25-8e0f-464e-9bcf-32c89596ed8)
这里的 `message.headers`就是在 compose 扩展方法 `additionalHeaders:`里拿到的。
​

第一次调用 decisionAction for message 方法时， 邮件其实在列表中还未可见。MEMessage 实例将只有消 息头的一个子集，也就是只包含了 headers 数据。如果需要完整的消息正文和标题才能返回对应的 action 操作，那么可以直接返回 invokeAgainWithBody。等内容下载完成之后再重新调用一次方法。
​

![image.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624093582648-1f45f330-8358-4988-a935-3744652739cf.png#clientId=uede728f9-e3ce-4&from=paste&height=116&id=u010508fa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=232&originWidth=1842&originalType=binary&ratio=2&size=175045&status=done&style=none&taskId=ud250a408-8bfd-4a8f-9838-e6c7b10a389&width=921)
所以完整的流程图是这样的。
![1624101919631-a3811c27-b1e8-4ffa-86c5-1b5190244579.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624101938748-d0866773-49e0-4fc9-8171-86863ced3bfa.png#clientId=u57db3155-f7d2-4&from=drop&id=u06e217f2&margin=%5Bobject%20Object%5D&name=1624101919631-a3811c27-b1e8-4ffa-86c5-1b5190244579.png&originHeight=2048&originWidth=2732&originalType=binary&ratio=2&size=1447358&status=done&style=none&taskId=ub3418f9c-2af9-438a-9384-e2ad9886428)


# Content blocking
这部分的内容会和浏览器上的广告屏蔽比较类似。就是将邮件内容用设置好的规则来判断是否显示。这些规则同样也是适用在 Safari 的 Content blocking 扩展里。
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624095548768-24a9c7a4-d85b-4a1d-80c5-6c55c73126d2.png#clientId=uede728f9-e3ce-4&from=drop&id=N6Mnu&margin=%5Bobject%20Object%5D&name=image.png&originHeight=144&originWidth=822&originalType=binary&ratio=2&size=32753&status=done&style=none&taskId=u69554a9e-45f4-442d-99fb-37592f127e1)
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624095801816-fca2385a-882a-4216-9038-c1b7e489295e.png#clientId=uede728f9-e3ce-4&from=paste&height=257&id=u95ce877a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=514&originWidth=2116&originalType=binary&ratio=2&size=584248&status=done&style=none&taskId=u49eec36d-78e8-499a-bbd5-486bae7c2d8&width=1058)
json 文件的内容
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624095842172-a9f3254f-ead3-43d6-809b-ebf09f37b3df.png#clientId=uede728f9-e3ce-4&from=paste&height=226&id=u8607009e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=452&originWidth=1002&originalType=binary&ratio=2&size=142448&status=done&style=none&taskId=ub23fea70-7b62-4108-abd8-749106aa543&width=501)
因为个人对于这方面没有过多的研究，所以就不展开。如果创建内容规则可以参考以下两个官方文档
[Introduction to WebKit Content Blockers](https://webkit.org/blog/3476/content-blockers-first-look/)
​[Content blocking rule](https://developer.apple.com/documentation/safariservices/creating_a_content_blocker)




# Message Security
信息的安全扩展功能，提供了一种更安全的邮件传输方式

1. 消息编码和解码
2. 消息签名
3. 查看签名信息证书

MEMessageSecurityHandler 协议继承自 MEMessageDecoder 和 MEMessageEncoder 
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624098982506-52ade2da-86d5-404b-ac50-6fcc64fd48f6.png#clientId=uede728f9-e3ce-4&from=paste&height=231&id=u181fe425&margin=%5Bobject%20Object%5D&name=image.png&originHeight=462&originWidth=1402&originalType=binary&ratio=2&size=212431&status=done&style=none&taskId=u1a042aa5-ab50-458d-8416-06d9dc179b4&width=701)
### MEMessageDecoder
对消息编码分为两部分
第一部分是获取是否可以编码的状态，方法调用发生在撰写邮件的时候
通过查询发件人和收件人列表，扩展程序会调用 `getEncodingStatus`方法来验证是否可以签名和加密。这时候会突出显示锁定和证书图标。在发件人和收件人发生改动的时候，也会调用方法重新验证
第二部分实际加密和签名，是在消息发送的时候实现
消息发送时，会将邮件的消息数据进行签名和加密得到结果，然后再发送出去。
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624098768982-45050ff7-3362-450a-a4fa-9024105cf824.png#clientId=uede728f9-e3ce-4&from=paste&height=164&id=ucc8679f8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=328&originWidth=952&originalType=binary&ratio=2&size=103538&status=done&style=none&taskId=u427e96af-7900-4e0e-95c8-4a8de8382a3&width=476)
### MEMessageEncoder
得到加密的结果，如果无法解密，那么就直接返回 nil
![3116BB62-F732-4220-B9DD-BE890BCCA7F0.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624102175140-e2d5b836-f244-4234-9652-0c2e9d464819.png#clientId=u56e1197e-033b-4&from=ui&id=u8116df56&margin=%5Bobject%20Object%5D&name=3116BB62-F732-4220-B9DD-BE890BCCA7F0.png&originHeight=2048&originWidth=2732&originalType=binary&ratio=2&size=2201815&status=done&style=none&taskId=ufe450dd7-e7d7-41b9-bd7e-36efc53c7c7)
​

在接受到加密和签名邮件时会在列表中展示对应的图标，实现 `extensionViewController`方法就可以获得签名信息 `MEMessageSigner`，通过视图展示完整的签名信息。签名者信息数据格式也已经定义好：
![E1CA2A5A-DB11-4CA5-BC23-CE39FC1013D6.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624102120632-f3a31daa-09be-4301-8268-645521797990.png#clientId=u56e1197e-033b-4&from=ui&id=u91caa3a0&margin=%5Bobject%20Object%5D&name=E1CA2A5A-DB11-4CA5-BC23-CE39FC1013D6.png&originHeight=2048&originWidth=2732&originalType=binary&ratio=2&size=2255524&status=done&style=none&taskId=u408ee9df-44fb-47bf-ba8d-49cacc09115)
# 结语

