本文基于 [Session 10168](https://developer.apple.com/videos/play/wwdc2021/10168/) 梳理


官方 [示例代码](https://developer.apple.com/documentation/mailkit/build_mail_app_extensions)


在 21 年的 WWDC 推出了一个邮件扩展的新框架 MailKit。这套框架的主要作用就是提升邮件使用的体验，框架实现的功能主要通过以下四个方面体现

1. Compose 
2. Action
3. Content blocking
4. Message security

MailKit 需要在 macOS 12.0+ 和 Xcode 12.5+ 的版本上使用。在 Xcode 选择 Target 时需要选中 Mail Extension。
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624107383217-89ebae45-e0be-4790-991f-573d6eacae71.png#clientId=u2a9b7a7a-2fbd-4&from=paste&height=373&id=u57ae70df&margin=%5Bobject%20Object%5D&name=image.png&originHeight=746&originWidth=1312&originalType=binary&ratio=2&size=98546&status=done&style=none&taskId=ud5faf5fc-32ca-4cc4-b0e5-2457a2926d3&width=656)

对应的扩展勾选上对应的选项。之后就正式开始开发了。
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624107415083-1ceabc72-cb01-47fb-bdb7-d3f964ce2d04.png#clientId=u2a9b7a7a-2fbd-4&from=paste&height=373&id=u61eac401&margin=%5Bobject%20Object%5D&name=image.png&originHeight=746&originWidth=1312&originalType=binary&ratio=2&size=156943&status=done&style=none&taskId=u365f6b7d-343a-460c-8683-a74267c30cb&width=656)

下面是官方示例代码的目录                               
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624107542127-c84ccee1-25ce-41f2-9060-428edd860632.png#clientId=u2a9b7a7a-2fbd-4&from=paste&height=587&id=u7efdd013&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1174&originWidth=474&originalType=binary&ratio=2&size=352927&status=done&style=none&taskId=u29ebcd4e-ad03-44c2-a2ac-6d079005c0c&width=237)

# Compose
copose 扩展的功能都定义在 MEComposeSessionHandler 这个协议里。在开发 Compose 扩展的时候，需要在 Info.plist 文件中，`MEComposeSession` 字典里，指定一个图标和工具的描述性文字。撰写邮件窗口内就会显示这个按钮。
一个图标和工具的描述性文字。撰写邮件窗口内就会显示这个按钮。
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624107475839-b3a3552f-7c2e-4fb0-a0eb-45970fd6c745.png#clientId=u2a9b7a7a-2fbd-4&from=paste&height=373&id=u546473f6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=746&originWidth=1312&originalType=binary&ratio=2&size=171267&status=done&style=none&taskId=u661a88e8-e06e-49fe-bef0-56be4d3dc29&width=656)

在协议里的方法，都包含了 `MEComposeSession` 这个参数类型。
邮件为每个邮件撰写窗口都创建了一个唯一的 `MEComposeSession` 实例。它有一个 `MEMessage` 属性，用于公开正在编辑的消息的各种详细信息。这些信息就可以在调用扩展程序的时候做对应的处理。不同的处理规则就可以通过和视图控制器进行选择和调整。
自定义消息表头 `headers` 这里先跳过，在后续中 `action` 再提到。
下面是方法的一些简单描述
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624089664154-04f97606-cc48-45fa-abdc-99eac68c2792.png#clientId=uede728f9-e3ce-4&from=paste&height=359&id=ufb2a0fd0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=718&originWidth=1414&originalType=binary&ratio=2&size=375502&status=done&style=none&taskId=u15efb591-1e1e-4cc6-a462-93b52c3f5dc&width=707)

### 验证收件人邮箱地址
每次在输入地址之后，会调用扩展中验证邮箱地址的有效性的方法，然后给出对应的状态。状态里分为 success/error/wraning 三种情况
![BFE7E706-F2CD-421B-8899-97D27B467A00.jpeg](https://cdn.nlark.com/yuque/0/2021/jpeg/1274781/1624101246172-b602fcd3-9390-469b-9d77-ae45b006f0ef.jpeg#clientId=u57db3155-f7d2-4&from=ui&id=uc0f01923&margin=%5Bobject%20Object%5D&name=BFE7E706-F2CD-421B-8899-97D27B467A00.jpeg&originHeight=99&originWidth=781&originalType=binary&ratio=2&size=20706&status=done&style=none&taskId=u20824c36-e241-4290-aa1b-7c8ad377e85)

### 视图控制器
这里的控制器，需要继承自 MEExtensionViewController 。通过视图控制器，我们就能够自己选择需要的上下文，然后来帮助我们提升在撰写邮件的使用体验。
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624108632804-de6082b8-05cb-4cc3-8780-88c46cdd3758.png#clientId=u2a9b7a7a-2fbd-4&from=paste&height=373&id=u92f3f506&margin=%5Bobject%20Object%5D&name=image.png&originHeight=746&originWidth=1312&originalType=binary&ratio=2&size=217597&status=done&style=none&taskId=u278ce806-a586-4dec-984e-b7a16182448&width=656)

### 邮件信息验证
在发送邮件之前，还可以对整个邮件内容做一次验证。包括邮件里包括的所有地址，还有邮件的内容。通过 `allowMessageSendForSession` 方法可以抛出信息验证的错误。要注意的是邮件的正文内容是以 Data 的形式返回。

# Action 
action 主要是用来处理新接收的邮件。这里需要主要：只是处理新接受的邮件，原有的邮件是不会收到影响的。处理的方式包括

1. 标记邮件列表中显示的背景色
2. 移动邮件到对应的邮件文件夹
3. 修改邮件的读取状态和标记

![image.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624094248589-ddedee7f-aadb-44b1-b9cb-98a9c83d0594.png#clientId=uede728f9-e3ce-4&from=paste&height=200&id=ua4c09b8a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=400&originWidth=1302&originalType=binary&ratio=2&size=178217&status=done&style=none&taskId=u6a70b913-990c-46dd-93a6-26cd3f8f5f9&width=651)

在session里，实现的是将邮件列表的背景色修改为红色。
这里的 `message.headers` 就是在 compose 扩展方法 `additionalHeaders:` 里拿到的。
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624108955755-5b812c42-a4e5-43e4-9eea-e1ef34a1e62c.png#clientId=u2a9b7a7a-2fbd-4&from=paste&height=373&id=u591fe044&margin=%5Bobject%20Object%5D&name=image.png&originHeight=746&originWidth=1312&originalType=binary&ratio=2&size=274818&status=done&style=none&taskId=u41946c15-2812-4126-815a-e559c42447a&width=656)

第一次调用 `decisionAction for message` 方法时， 邮件其实在列表中还未可见。MEMessage 实例将只有消 息头的一个子集，也就是只包含了 headers 数据。如果需要完整的消息正文和标题才能返回对应的 action 操作，那么可以直接返回 invokeAgainWithBody。等内容下载完成之后再重新调用一次方法。
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624093582648-1f45f330-8358-4988-a935-3744652739cf.png#clientId=uede728f9-e3ce-4&from=paste&height=116&id=u010508fa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=232&originWidth=1842&originalType=binary&ratio=2&size=175045&status=done&style=none&taskId=ud250a408-8bfd-4a8f-9838-e6c7b10a389&width=921)

所以完整的流程图是这样的。
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624108955755-5b812c42-a4e5-43e4-9eea-e1ef34a1e62c.png#clientId=u2a9b7a7a-2fbd-4&from=paste&height=373&id=u591fe044&margin=%5Bobject%20Object%5D&name=image.png&originHeight=746&originWidth=1312&originalType=binary&ratio=2&size=274818&status=done&style=none&taskId=u41946c15-2812-4126-815a-e559c42447a&width=656)

# Content blocking
这部分的内容会和浏览器上的广告屏蔽比较类似。就是将邮件内容用设置好的规则来判断是否显示。这些规则同样也是适用在 Safari 的 Content blocking 扩展里。
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624095548768-24a9c7a4-d85b-4a1d-80c5-6c55c73126d2.png#clientId=uede728f9-e3ce-4&from=drop&id=N6Mnu&margin=%5Bobject%20Object%5D&name=image.png&originHeight=144&originWidth=822&originalType=binary&ratio=2&size=32753&status=done&style=none&taskId=u69554a9e-45f4-442d-99fb-37592f127e1)

在 `contentRulesJSON` 方法里，返回的是内容屏蔽规则的 json 文件，文件的内容大概长这个样子
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624095842172-a9f3254f-ead3-43d6-809b-ebf09f37b3df.png#clientId=uede728f9-e3ce-4&from=paste&height=226&id=u8607009e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=452&originWidth=1002&originalType=binary&ratio=2&size=142448&status=done&style=none&taskId=ub23fea70-7b62-4108-abd8-749106aa543&width=501)

因为个人对于这方面没有过多的研究，所以就不展开。如果创建内容规则可以参考以下两个官方文档
[Introduction to WebKit Content Blockers](https://webkit.org/blog/3476/content-blockers-first-look/)
[Content blocking rule](https://developer.apple.com/documentation/safariservices/creating_a_content_blocker)

# Message Security
信息的安全扩展功能，提供了一种更安全的邮件传输方式

1. 消息编码和解码
2. 消息签名
3. 查看签名信息证书

MEMessageSecurityHandler 协议继承自 MEMessageDecoder 和 MEMessageEncoder 
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624109554399-e372e5c0-03fe-42e7-a92a-35b7a5072411.png#clientId=u2a9b7a7a-2fbd-4&from=paste&height=236&id=u2242bacc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=472&originWidth=1246&originalType=binary&ratio=2&size=209514&status=done&style=none&taskId=ua04f8259-3af1-47cc-a864-618785ddd88&width=623)

### MEMessageDecoder
对消息编码分为两部分
第一部分是获取是否可以编码的状态，方法调用发生在撰写邮件的时候
通过查询发件人和收件人列表，扩展程序会调用 `getEncodingStatus` 方法来验证是否可以签名和加密。这时候会突出显示锁定和证书图标。在发件人和收件人发生改动的时候，也会调用方法重新验证
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624109693675-637f1bfb-da89-4207-9f51-c94a84d8507a.png#clientId=u2a9b7a7a-2fbd-4&from=paste&height=373&id=u56777ca1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=746&originWidth=1312&originalType=binary&ratio=2&size=179843&status=done&style=none&taskId=u84affa5d-2f9b-4c82-ae27-10182c2c89d&width=656)

第二部分实际加密和签名，是在消息发送的时候实现
消息发送时，会将邮件的消息数据进行签名和加密得到结果，然后再发送出去。
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624109988318-86c3e576-8132-44cf-b51a-6fce9d0ec42b.png#clientId=u2a9b7a7a-2fbd-4&from=paste&height=373&id=u3d2f052c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=746&originWidth=1312&originalType=binary&ratio=2&size=332689&status=done&style=none&taskId=u202519c2-55bc-432a-9ac5-a77579a3d1b&width=656)

官方示例代码里底层的实现方式如下图。其中 `isSigned` 和 `isEncrypted` 参数应该由 ecode 方法传递进来的
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624098768982-45050ff7-3362-450a-a4fa-9024105cf824.png#clientId=uede728f9-e3ce-4&from=paste&height=164&id=ucc8679f8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=328&originWidth=952&originalType=binary&ratio=2&size=103538&status=done&style=none&taskId=u427e96af-7900-4e0e-95c8-4a8de8382a3&width=476)

### MEMessageEncoder
得到加密的结果，如果无法解密，那么就直接返回 nil
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624110051396-e3a5dde8-40de-4df5-a712-fc7c80df9201.png#clientId=u2a9b7a7a-2fbd-4&from=paste&height=373&id=u7c8a8773&margin=%5Bobject%20Object%5D&name=image.png&originHeight=746&originWidth=1312&originalType=binary&ratio=2&size=347255&status=done&style=none&taskId=u9693d627-f99c-480d-829b-2904abe7014&width=656)

在接受到加密和签名邮件时会在列表中展示对应的图标，实现 `extensionViewController` 方法就可以获得签名信息 `MEMessageSigner`，通过视图展示完整的签名信息。
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624110096748-43eabba9-7cf5-4e69-9b1f-8a08523779b1.png#clientId=u2a9b7a7a-2fbd-4&from=paste&height=373&id=ud4a149c3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=746&originWidth=1312&originalType=binary&ratio=2&size=111471&status=done&style=none&taskId=ubc62f365-06ae-4ee7-8ffa-e27423defea&width=656)

# 结语
因为是一个全新的框架，所以本文主要以扫盲为主。另外 Mac 原生邮件软件总体来说用户不是很多，而且就连 Safari 的扩展生态都不是很好，就更别谈邮件的扩展了。
不过总开发上来说也是学习官方代码的一个好机会。功能不复杂，结构也很清晰。可以学习以协议的实现逻辑来实现现有功能的扩展需求。
最后是 MailKit 完整的思维导图
![MailKit.png](https://cdn.nlark.com/yuque/0/2021/png/1274781/1624106655635-e1826187-d99a-4fb4-9de7-101bf0f1f041.png#clientId=u0879fa10-5971-4&from=drop&id=u5f89ddf0&margin=%5Bobject%20Object%5D&name=MailKit.png&originHeight=2154&originWidth=8246&originalType=binary&ratio=2&size=1097666&status=done&style=none&taskId=u3b0ecf4f-f993-4ea4-b8be-7529e2c6e7f)

